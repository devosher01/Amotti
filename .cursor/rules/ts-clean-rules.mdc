---
alwaysApply: true
---

# Gu√≠a Completa: Clean Architecture para Frontend (TypeScript + React)

## CONCEPTOS FUNDAMENTALES

### COMANDO: Entiende los 3 principios b√°sicos
1. **Separaci√≥n por proximidad al dominio**: Cuanto m√°s cerca del centro, m√°s importante para el negocio
2. **Dominio independiente**: La l√≥gica de negocio no debe depender de frameworks o servicios externos
3. **Adaptaci√≥n externa**: Los servicios externos se adaptan a nuestras necesidades, no al rev√©s

## ESTRUCTURA DE CARPETAS OBLIGATORIA

```
src/
‚îú‚îÄ‚îÄ domain/                    # CENTRO: Entidades y transformaciones
‚îÇ   ‚îú‚îÄ‚îÄ user.ts               # Tipos y funciones de usuario
‚îÇ   ‚îú‚îÄ‚îÄ product.ts            # Tipos y funciones de producto
‚îÇ   ‚îú‚îÄ‚îÄ cart.ts               # Tipos y funciones de carrito
‚îÇ   ‚îî‚îÄ‚îÄ order.ts              # Tipos y funciones de orden
‚îú‚îÄ‚îÄ application/              # CAPA 2: Casos de uso y puertos
‚îÇ   ‚îú‚îÄ‚îÄ addToCart.ts          # Caso de uso: agregar al carrito
‚îÇ   ‚îú‚îÄ‚îÄ authenticate.ts       # Caso de uso: autenticaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ orderProducts.ts      # Caso de uso: procesar orden
‚îÇ   ‚îî‚îÄ‚îÄ ports.ts              # Interfaces para servicios externos
‚îú‚îÄ‚îÄ services/                 # CAPA 3: Adaptadores
‚îÇ   ‚îú‚îÄ‚îÄ authAdapter.ts        # Adaptador de autenticaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ notificationAdapter.ts # Adaptador de notificaciones
‚îÇ   ‚îú‚îÄ‚îÄ paymentAdapter.ts     # Adaptador de pagos
‚îÇ   ‚îú‚îÄ‚îÄ storageAdapter.ts     # Adaptador de almacenamiento
‚îÇ   ‚îú‚îÄ‚îÄ api.ts                # Cliente API
‚îÇ   ‚îî‚îÄ‚îÄ store.tsx             # Store global (React Context)
‚îú‚îÄ‚îÄ ui/                       # CAPA 3: Componentes React
‚îÇ   ‚îî‚îÄ‚îÄ components/
‚îú‚îÄ‚îÄ lib/                      # Utilidades t√©cnicas
‚îî‚îÄ‚îÄ shared-kernel.d.ts        # Tipos compartidos globales
```

## REGLA DE DEPENDENCIAS (INVIOLABLE)

**COMANDO FUNDAMENTAL**: Las dependencias SIEMPRE apuntan hacia el centro
- ‚úÖ `domain/` ‚Üí NO DEPENDE DE NADA (ni siquiera de `lib/`)
- ‚úÖ `application/` ‚Üí Solo puede importar de `domain/`
- ‚úÖ `services/` y `ui/` ‚Üí Pueden importar de `application/` y `domain/`
- ‚ùå NUNCA al rev√©s

```
[UI/Services] ‚Üí [Application] ‚Üí [Domain]
```

## PASO 1: CREAR SHARED KERNEL

**COMANDO**: Define tipos primitivos mejorados ANTES que todo

```typescript
// shared-kernel.d.ts
type Email = string;
type UniqueId = string;
type DateTimeString = string;
type PriceCents = number;
type Ingredient = string;

// Para mejor tipado (recomendado)
type Currency = "USD" | "EUR" | "COP";
type Price = {
  value: PriceCents;
  currency: Currency;
};
```

**REGLAS DEL SHARED KERNEL**:
- Solo tipos que CUALQUIER parte del sistema pueda usar
- Basado en tipos primitivos del lenguaje
- No aumenta acoplamiento entre m√≥dulos
- M√≠nimo indispensable

## PASO 2: DISE√ëAR DOMINIO (DOMAIN LAYER)

### COMANDO: Crea tipos de entidades principales

```typescript
// domain/user.ts
export type UserName = string;
export type User = {
  id: UniqueId;
  name: UserName;
  email: Email;
  preferences: Ingredient[];
  allergies: Ingredient[];
};

// domain/product.ts
export type ProductTitle = string;
export type Product = {
  id: UniqueId;
  title: ProductTitle;
  price: PriceCents;
  toppings: Ingredient[];
};

// domain/cart.ts
export type Cart = {
  products: Product[];
};

// domain/order.ts
export type OrderStatus = "new" | "delivery" | "completed";
export type Order = {
  user: UniqueId;
  cart: Cart;
  created: DateTimeString;
  status: OrderStatus;
  total: PriceCents;
};
```

### COMANDO: Crea funciones de transformaci√≥n puras

**REGLA**: Todas las funciones deben ser puras (sin efectos secundarios)

```typescript
// domain/user.ts
export function hasAllergy(user: User, ingredient: Ingredient): boolean {
  return user.allergies.includes(ingredient);
}

export function hasPreference(user: User, ingredient: Ingredient): boolean {
  return user.preferences.includes(ingredient);
}

// domain/cart.ts
export function addProduct(cart: Cart, product: Product): Cart {
  return { ...cart, products: [...cart.products, product] };
}

export function contains(cart: Cart, product: Product): boolean {
  return cart.products.some(({ id }) => id === product.id);
}

// domain/product.ts
export function totalPrice(products: Product[]): PriceCents {
  return products.reduce((total, { price }) => total + price, 0);
}

// domain/order.ts
export function createOrder(user: User, cart: Cart): Order {
  return {
    user: user.id,
    cart,
    created: new Date().toISOString(),
    status: "new",
    total: totalPrice(cart.products),
  };
}
```

### COMANDO: Valida relaciones entre entidades
- Dibuja diagrama de entidades
- Verifica que las relaciones tengan sentido
- Aseg√∫rate de que tienes toda la informaci√≥n necesaria

## PASO 3: DISE√ëAR PUERTOS (APPLICATION LAYER)

### COMANDO: Define puertos convenientes para TU aplicaci√≥n

**REGLA**: Los puertos reflejan lo que TU aplicaci√≥n necesita, no lo que ofrecen servicios externos

```typescript
// application/ports.ts

// Puerto para pagos
export interface PaymentService {
  tryPay(amount: PriceCents): Promise<boolean>;
}

// Puerto para notificaciones
export interface NotificationService {
  notify(message: string): void;
}

// Puerto para almacenamiento local
export interface OrdersStorageService {
  orders: Order[];
  updateOrders(orders: Order[]): void;
}

export interface CartStorageService {
  cart: Cart;
  updateCart(cart: Cart): void;
  emptyCart(): void;
}

// Puerto para persistencia
export interface ApiService {
  saveOrder(order: Order): Promise<void>;
  getProducts(): Promise<Product[]>;
}
```

## PASO 4: IMPLEMENTAR CASOS DE USO

### COMANDO: Usa el patr√≥n "sandwich" para casos de uso

**PATR√ìN OBLIGATORIO**: Efecto secundario ‚Üí Transformaci√≥n pura ‚Üí Efecto secundario

```typescript
// application/orderProducts.ts

// Stubs temporales para dise√±o
const payment: PaymentService = {} as PaymentService;
const notifier: NotificationService = {} as NotificationService;
const orderStorage: OrdersStorageService = {} as OrdersStorageService;
const cartStorage: CartStorageService = {} as CartStorageService;

async function orderProducts(user: User, cart: Cart) {
  // 1. Transformaci√≥n pura (dominio)
  const order = createOrder(user, cart);

  // 2. Efecto secundario (pago)
  const paid = await payment.tryPay(order.total);
  if (!paid) return notifier.notify("Oops! ü§∑");

  // 3. Efecto secundario (almacenamiento)
  const { orders } = orderStorage;
  orderStorage.updateOrders([...orders, order]);
  cartStorage.emptyCart();
}
```

### COMANDO: Integra casos de uso con React usando hooks

```typescript
// application/orderProducts.ts
export function useOrderProducts() {
  const notifier = useNotifier();
  const payment = usePayment();
  const orderStorage = useOrdersStorage();
  const cartStorage = useCartStorage();

  async function orderProducts(user: User, cart: Cart) {
    const order = createOrder(user, cart);

    const paid = await payment.tryPay(order.total);
    if (!paid) return notifier.notify("Oops! ü§∑");

    const { orders } = orderStorage;
    orderStorage.updateOrders([...orders, order]);
    cartStorage.emptyCart();
  }

  return { orderProducts };
}
```

**NOTA**: El hook act√∫a como "dependency injection rudimentario" usando closures

## PASO 5: IMPLEMENTAR ADAPTADORES

### COMANDO: Crea adaptadores para servicios reales

```typescript
// services/paymentAdapter.ts
import { PaymentService } from "../application/ports";
import { fakeApi } from "./api";

export function usePayment(): PaymentService {
  return {
    tryPay(amount: PriceCents) {
      // Simula llamada a servicio real
      return fakeApi(true);
    },
  };
}

// services/notificationAdapter.ts
import { NotificationService } from "../application/ports";

export function useNotifier(): NotificationService {
  return {
    notify: (message: string) => window.alert(message),
  };
}

// services/api.ts
export function fakeApi<TResponse>(response: TResponse): Promise<TResponse> {
  return new Promise((res) => setTimeout(() => res(response), 450));
}
```

### COMANDO: Implementa almacenamiento con React Context

```typescript
// services/store.tsx
const StoreContext = React.createContext<any>({});
export const useStore = () => useContext(StoreContext);

export const Provider: React.FC = ({ children }) => {
  const [orders, setOrders] = useState<Order[]>([]);
  const [cart, setCart] = useState<Cart>({ products: [] });

  const value = {
    orders,
    updateOrders: setOrders,
    cart,
    updateCart: setCart,
    emptyCart: () => setCart({ products: [] }),
  };

  return (
    <StoreContext.Provider value={value}>
      {children}
    </StoreContext.Provider>
  );
};

// services/storageAdapter.ts
export function useOrdersStorage(): OrdersStorageService {
  return useStore();
}

export function useCartStorage(): CartStorageService {
  return useStore();
}
```

### COMANDO: Conecta UI con casos de uso

```typescript
// ui/components/Buy.tsx
export function Buy() {
  const { orderProducts } = useOrderProducts();
  const [loading, setLoading] = useState(false);

  async function handleSubmit(e: React.FormEvent) {
    setLoading(true);
    e.preventDefault();

    // Llamada directa al caso de uso
    await orderProducts(user!, cart);
    setLoading(false);
  }

  return (
    <section>
      <h2>Checkout</h2>
      <form onSubmit={handleSubmit}>
        <button type="submit" disabled={loading}>
          {loading ? "Processing..." : "Order Now"}
        </button>
      </form>
    </section>
  );
}
```

## MEJORES PR√ÅCTICAS ESPEC√çFICAS PARA FRONTEND

### COMANDO: Maneja precios correctamente

```typescript
// ‚ùå Malo: solo n√∫mero
type PriceCents = number;

// ‚úÖ Bueno: objeto con moneda
type Currency = "USD" | "EUR" | "COP";
type Price = {
  value: PriceCents;
  currency: Currency;
};
```

**REGLA**: Siempre almacena dinero en la fracci√≥n m√°s peque√±a (centavos)

### COMANDO: Evita dependencias en el dominio

```typescript
// ‚ùå Malo: dependencia oculta
export function createOrder(user: User, cart: Cart): Order {
  return {
    // ...
    created: new Date().toISOString(), // Dependencia!
  };
}

// ‚úÖ Bueno: inyecta dependencias
export function createOrder(
  user: User, 
  cart: Cart, 
  created: DateTimeString
): Order {
  return {
    // ...
    created,
  };
}
```

### COMANDO: Usa branded types para mayor seguridad

```typescript
// En lugar de type aliases simples
type UserId = string & { readonly brand: unique symbol };
type Email = string & { readonly brand: unique symbol };

// Funci√≥n helper para crear branded types
function createUserId(value: string): UserId {
  return value as UserId;
}
```

### COMANDO: Organiza por componentes para proyectos grandes

```
// Alternativa para proyectos complejos
src/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ authentication/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ adapters/
‚îÇ   ‚îú‚îÄ‚îÄ user-management/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ adapters/
‚îÇ   ‚îî‚îÄ‚îÄ billing/
‚îÇ       ‚îú‚îÄ‚îÄ domain/
‚îÇ       ‚îú‚îÄ‚îÄ application/
‚îÇ       ‚îî‚îÄ‚îÄ adapters/
```

### COMANDO: Haz casos de uso m√°s testeable

```typescript
// ‚ùå Malo: dif√≠cil de testear
export function useOrderProducts() {
  const services = getServices(); // Acoplado a React
  
  async function orderProducts(user: User, cart: Cart) {
    // l√≥gica acoplada
  }
  
  return { orderProducts };
}

// ‚úÖ Bueno: f√°cil de testear
type Dependencies = {
  notifier?: NotificationService;
  payment?: PaymentService;
  orderStorage?: OrderStorageService;
};

async function orderProducts(
  user: User,
  cart: Cart,
  dependencies: Dependencies = defaultDependencies
) {
  const { notifier, payment, orderStorage } = dependencies;
  // l√≥gica pura
}

// Hook como adaptador
function useOrderProducts() {
  const notifier = useNotifier();
  const payment = usePayment();
  const orderStorage = useOrdersStorage();

  return (user: User, cart: Cart) =>
    orderProducts(user, cart, { notifier, payment, orderStorage });
}
```

## COMANDOS DE VALIDACI√ìN

### COMANDO: Verifica tu implementaci√≥n

‚úÖ **Checklist obligatorio**:
- ¬øEl dominio no importa nada externo?
- ¬øLos casos de uso siguen el patr√≥n sandwich?
- ¬øLos puertos reflejan TUS necesidades?
- ¬øLos adaptadores traducen APIs externas?
- ¬øLas dependencias apuntan hacia el centro?

### COMANDO: Se√±ales de problemas

‚ùå **Red flags**:
- Importar frameworks en el dominio
- Casos de uso que conocen detalles de UI
- Puertos que copian APIs externas
- L√≥gica de negocio esparcida por la aplicaci√≥n
- Dificultad para testear sin UI

## CU√ÅNDO APLICAR CLEAN ARCHITECTURE

### COMANDO: Eval√∫a tu proyecto

**APLICA COMPLETO si**:
- Proyecto de mediano/largo plazo
- M√∫ltiples desarrolladores
- Requisitos cambiantes frecuentes
- Necesitas intercambiar servicios externos

**APLICA M√çNIMO si**:
- Proyecto peque√±o o prototipo
- Solo 1-2 desarrolladores
- Requisitos estables
- Tiempo limitado

**M√çNIMO INDISPENSABLE**:
1. Extrae el dominio
2. Respeta la regla de dependencias

### COMANDO: Maneja l√≥gica de negocio compleja

**REGLAS PRAGM√ÅTICAS**:
- NO uses herencia inmediatamente
- HAZ copy-paste primero, refactoriza despu√©s
- OBSERVA patrones antes de abstraer
- DESCOMP√ìN casos de uso interdependientes

## FLUJO DE DESARROLLO RECOMENDADO

### COMANDO: Sigue este orden SIEMPRE

1. **Dise√±a entidades del dominio**: Tipos y transformaciones puras
2. **Define puertos**: Qu√© necesita tu aplicaci√≥n del mundo exterior
3. **Implementa casos de uso**: Orquestaci√≥n usando puertos y dominio
4. **Crea adaptadores**: Implementaci√≥n real de puertos
5. **Conecta UI**: Componentes que usan casos de uso via hooks

### COMANDO: Validaci√≥n continua

En cada paso, preg√∫ntate:
- ¬øLas dependencias apuntan hacia adentro?
- ¬øPuedo testear esta parte aisladamente?
- ¬øPuedo cambiar tecnolog√≠as sin afectar el dominio?

---

**RECUERDA**: Clean Architecture es una herramienta para gestionar complejidad. Para proyectos simples, enf√≥cate en extraer dominio y respetar dependencias. Para proyectos complejos, aplica toda la arquitectura.





## NEXT JS 14 EN ADELANTE

# Gu√≠a Completa: Clean Architecture para Frontend (TypeScript + React)

## CONCEPTOS FUNDAMENTALES

### COMANDO: Entiende los 3 principios b√°sicos
1. **Separaci√≥n por proximidad al dominio**: Cuanto m√°s cerca del centro, m√°s importante para el negocio
2. **Dominio independiente**: La l√≥gica de negocio no debe depender de frameworks o servicios externos
3. **Adaptaci√≥n externa**: Los servicios externos se adaptan a nuestras necesidades, no al rev√©s

## ESTRUCTURA DE CARPETAS OBLIGATORIA

```
src/
‚îú‚îÄ‚îÄ domain/                    # CENTRO: Entidades y transformaciones
‚îÇ   ‚îú‚îÄ‚îÄ user.ts               # Tipos y funciones de usuario
‚îÇ   ‚îú‚îÄ‚îÄ product.ts            # Tipos y funciones de producto
‚îÇ   ‚îú‚îÄ‚îÄ cart.ts               # Tipos y funciones de carrito
‚îÇ   ‚îî‚îÄ‚îÄ order.ts              # Tipos y funciones de orden
‚îú‚îÄ‚îÄ application/              # CAPA 2: Casos de uso y puertos
‚îÇ   ‚îú‚îÄ‚îÄ addToCart.ts          # Caso de uso: agregar al carrito
‚îÇ   ‚îú‚îÄ‚îÄ authenticate.ts       # Caso de uso: autenticaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ orderProducts.ts      # Caso de uso: procesar orden
‚îÇ   ‚îî‚îÄ‚îÄ ports.ts              # Interfaces para servicios externos
‚îú‚îÄ‚îÄ services/                 # CAPA 3: Adaptadores
‚îÇ   ‚îú‚îÄ‚îÄ authAdapter.ts        # Adaptador de autenticaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ notificationAdapter.ts # Adaptador de notificaciones
‚îÇ   ‚îú‚îÄ‚îÄ paymentAdapter.ts     # Adaptador de pagos
‚îÇ   ‚îú‚îÄ‚îÄ storageAdapter.ts     # Adaptador de almacenamiento
‚îÇ   ‚îú‚îÄ‚îÄ api.ts                # Cliente API
‚îÇ   ‚îî‚îÄ‚îÄ store.tsx             # Store global (React Context)
‚îú‚îÄ‚îÄ ui/                       # CAPA 3: Componentes React
‚îÇ   ‚îî‚îÄ‚îÄ components/
‚îú‚îÄ‚îÄ lib/                      # Utilidades t√©cnicas
‚îî‚îÄ‚îÄ shared-kernel.d.ts        # Tipos compartidos globales
```

## REGLA DE DEPENDENCIAS (INVIOLABLE)

**COMANDO FUNDAMENTAL**: Las dependencias SIEMPRE apuntan hacia el centro
- ‚úÖ `domain/` ‚Üí NO DEPENDE DE NADA (ni siquiera de `lib/`)
- ‚úÖ `application/` ‚Üí Solo puede importar de `domain/`
- ‚úÖ `services/` y `ui/` ‚Üí Pueden importar de `application/` y `domain/`
- ‚ùå NUNCA al rev√©s

```
[UI/Services] ‚Üí [Application] ‚Üí [Domain]
```

## PASO 1: CREAR SHARED KERNEL

**COMANDO**: Define tipos primitivos mejorados ANTES que todo

```typescript
// shared-kernel.d.ts
type Email = string;
type UniqueId = string;
type DateTimeString = string;
type PriceCents = number;
type Ingredient = string;

// Para mejor tipado (recomendado)
type Currency = "USD" | "EUR" | "COP";
type Price = {
  value: PriceCents;
  currency: Currency;
};
```

**REGLAS DEL SHARED KERNEL**:
- Solo tipos que CUALQUIER parte del sistema pueda usar
- Basado en tipos primitivos del lenguaje
- No aumenta acoplamiento entre m√≥dulos
- M√≠nimo indispensable

## PASO 2: DISE√ëAR DOMINIO (DOMAIN LAYER)

### COMANDO: Crea tipos de entidades principales

```typescript
// domain/user.ts
export type UserName = string;
export type User = {
  id: UniqueId;
  name: UserName;
  email: Email;
  preferences: Ingredient[];
  allergies: Ingredient[];
};

// domain/product.ts
export type ProductTitle = string;
export type Product = {
  id: UniqueId;
  title: ProductTitle;
  price: PriceCents;
  toppings: Ingredient[];
};

// domain/cart.ts
export type Cart = {
  products: Product[];
};

// domain/order.ts
export type OrderStatus = "new" | "delivery" | "completed";
export type Order = {
  user: UniqueId;
  cart: Cart;
  created: DateTimeString;
  status: OrderStatus;
  total: PriceCents;
};
```

### COMANDO: Crea funciones de transformaci√≥n puras

**REGLA**: Todas las funciones deben ser puras (sin efectos secundarios)

```typescript
// domain/user.ts
export function hasAllergy(user: User, ingredient: Ingredient): boolean {
  return user.allergies.includes(ingredient);
}

export function hasPreference(user: User, ingredient: Ingredient): boolean {
  return user.preferences.includes(ingredient);
}

// domain/cart.ts
export function addProduct(cart: Cart, product: Product): Cart {
  return { ...cart, products: [...cart.products, product] };
}

export function contains(cart: Cart, product: Product): boolean {
  return cart.products.some(({ id }) => id === product.id);
}

// domain/product.ts
export function totalPrice(products: Product[]): PriceCents {
  return products.reduce((total, { price }) => total + price, 0);
}

// domain/order.ts
export function createOrder(user: User, cart: Cart): Order {
  return {
    user: user.id,
    cart,
    created: new Date().toISOString(),
    status: "new",
    total: totalPrice(cart.products),
  };
}
```

### COMANDO: Valida relaciones entre entidades
- Dibuja diagrama de entidades
- Verifica que las relaciones tengan sentido
- Aseg√∫rate de que tienes toda la informaci√≥n necesaria

## PASO 3: DISE√ëAR PUERTOS (APPLICATION LAYER)

### COMANDO: Define puertos convenientes para TU aplicaci√≥n

**REGLA**: Los puertos reflejan lo que TU aplicaci√≥n necesita, no lo que ofrecen servicios externos

```typescript
// application/ports.ts

// Puerto para pagos
export interface PaymentService {
  tryPay(amount: PriceCents): Promise<boolean>;
}

// Puerto para notificaciones
export interface NotificationService {
  notify(message: string): void;
}

// Puerto para almacenamiento local
export interface OrdersStorageService {
  orders: Order[];
  updateOrders(orders: Order[]): void;
}

export interface CartStorageService {
  cart: Cart;
  updateCart(cart: Cart): void;
  emptyCart(): void;
}

// Puerto para persistencia
export interface ApiService {
  saveOrder(order: Order): Promise<void>;
  getProducts(): Promise<Product[]>;
}
```

## PASO 4: IMPLEMENTAR CASOS DE USO

### COMANDO: Usa el patr√≥n "sandwich" para casos de uso

**PATR√ìN OBLIGATORIO**: Efecto secundario ‚Üí Transformaci√≥n pura ‚Üí Efecto secundario

```typescript
// application/orderProducts.ts

// Stubs temporales para dise√±o
const payment: PaymentService = {} as PaymentService;
const notifier: NotificationService = {} as NotificationService;
const orderStorage: OrdersStorageService = {} as OrdersStorageService;
const cartStorage: CartStorageService = {} as CartStorageService;

async function orderProducts(user: User, cart: Cart) {
  // 1. Transformaci√≥n pura (dominio)
  const order = createOrder(user, cart);

  // 2. Efecto secundario (pago)
  const paid = await payment.tryPay(order.total);
  if (!paid) return notifier.notify("Oops! ü§∑");

  // 3. Efecto secundario (almacenamiento)
  const { orders } = orderStorage;
  orderStorage.updateOrders([...orders, order]);
  cartStorage.emptyCart();
}
```

### COMANDO: Integra casos de uso con React usando hooks

```typescript
// application/orderProducts.ts
export function useOrderProducts() {
  const notifier = useNotifier();
  const payment = usePayment();
  const orderStorage = useOrdersStorage();
  const cartStorage = useCartStorage();

  async function orderProducts(user: User, cart: Cart) {
    const order = createOrder(user, cart);

    const paid = await payment.tryPay(order.total);
    if (!paid) return notifier.notify("Oops! ü§∑");

    const { orders } = orderStorage;
    orderStorage.updateOrders([...orders, order]);
    cartStorage.emptyCart();
  }

  return { orderProducts };
}
```

**NOTA**: El hook act√∫a como "dependency injection rudimentario" usando closures

## PASO 5: IMPLEMENTAR ADAPTADORES

### COMANDO: Crea adaptadores para servicios reales

```typescript
// services/paymentAdapter.ts
import { PaymentService } from "../application/ports";
import { fakeApi } from "./api";

export function usePayment(): PaymentService {
  return {
    tryPay(amount: PriceCents) {
      // Simula llamada a servicio real
      return fakeApi(true);
    },
  };
}

// services/notificationAdapter.ts
import { NotificationService } from "../application/ports";

export function useNotifier(): NotificationService {
  return {
    notify: (message: string) => window.alert(message),
  };
}

// services/api.ts
export function fakeApi<TResponse>(response: TResponse): Promise<TResponse> {
  return new Promise((res) => setTimeout(() => res(response), 450));
}
```

### COMANDO: Implementa almacenamiento con React Context

```typescript
// services/store.tsx
const StoreContext = React.createContext<any>({});
export const useStore = () => useContext(StoreContext);

export const Provider: React.FC = ({ children }) => {
  const [orders, setOrders] = useState<Order[]>([]);
  const [cart, setCart] = useState<Cart>({ products: [] });

  const value = {
    orders,
    updateOrders: setOrders,
    cart,
    updateCart: setCart,
    emptyCart: () => setCart({ products: [] }),
  };

  return (
    <StoreContext.Provider value={value}>
      {children}
    </StoreContext.Provider>
  );
};

// services/storageAdapter.ts
export function useOrdersStorage(): OrdersStorageService {
  return useStore();
}

export function useCartStorage(): CartStorageService {
  return useStore();
}
```

### COMANDO: Conecta UI con casos de uso

```typescript
// ui/components/Buy.tsx
export function Buy() {
  const { orderProducts } = useOrderProducts();
  const [loading, setLoading] = useState(false);

  async function handleSubmit(e: React.FormEvent) {
    setLoading(true);
    e.preventDefault();

    // Llamada directa al caso de uso
    await orderProducts(user!, cart);
    setLoading(false);
  }

  return (
    <section>
      <h2>Checkout</h2>
      <form onSubmit={handleSubmit}>
        <button type="submit" disabled={loading}>
          {loading ? "Processing..." : "Order Now"}
        </button>
      </form>
    </section>
  );
}
```

## MEJORES PR√ÅCTICAS ESPEC√çFICAS PARA FRONTEND

### COMANDO: Maneja precios correctamente

```typescript
// ‚ùå Malo: solo n√∫mero
type PriceCents = number;

// ‚úÖ Bueno: objeto con moneda
type Currency = "USD" | "EUR" | "COP";
type Price = {
  value: PriceCents;
  currency: Currency;
};
```

**REGLA**: Siempre almacena dinero en la fracci√≥n m√°s peque√±a (centavos)

### COMANDO: Evita dependencias en el dominio

```typescript
// ‚ùå Malo: dependencia oculta
export function createOrder(user: User, cart: Cart): Order {
  return {
    // ...
    created: new Date().toISOString(), // Dependencia!
  };
}

// ‚úÖ Bueno: inyecta dependencias
export function createOrder(
  user: User, 
  cart: Cart, 
  created: DateTimeString
): Order {
  return {
    // ...
    created,
  };
}
```

### COMANDO: Usa branded types para mayor seguridad

```typescript
// En lugar de type aliases simples
type UserId = string & { readonly brand: unique symbol };
type Email = string & { readonly brand: unique symbol };

// Funci√≥n helper para crear branded types
function createUserId(value: string): UserId {
  return value as UserId;
}
```

### COMANDO: Organiza por componentes para proyectos grandes

```
// Alternativa para proyectos complejos
src/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ authentication/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ adapters/
‚îÇ   ‚îú‚îÄ‚îÄ user-management/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ adapters/
‚îÇ   ‚îî‚îÄ‚îÄ billing/
‚îÇ       ‚îú‚îÄ‚îÄ domain/
‚îÇ       ‚îú‚îÄ‚îÄ application/
‚îÇ       ‚îî‚îÄ‚îÄ adapters/
```

### COMANDO: Haz casos de uso m√°s testeable

```typescript
// ‚ùå Malo: dif√≠cil de testear
export function useOrderProducts() {
  const services = getServices(); // Acoplado a React
  
  async function orderProducts(user: User, cart: Cart) {
    // l√≥gica acoplada
  }
  
  return { orderProducts };
}

// ‚úÖ Bueno: f√°cil de testear
type Dependencies = {
  notifier?: NotificationService;
  payment?: PaymentService;
  orderStorage?: OrderStorageService;
};

async function orderProducts(
  user: User,
  cart: Cart,
  dependencies: Dependencies = defaultDependencies
) {
  const { notifier, payment, orderStorage } = dependencies;
  // l√≥gica pura
}

// Hook como adaptador
function useOrderProducts() {
  const notifier = useNotifier();
  const payment = usePayment();
  const orderStorage = useOrdersStorage();

  return (user: User, cart: Cart) =>
    orderProducts(user, cart, { notifier, payment, orderStorage });
}
```

## COMANDOS DE VALIDACI√ìN

### COMANDO: Verifica tu implementaci√≥n

‚úÖ **Checklist obligatorio**:
- ¬øEl dominio no importa nada externo?
- ¬øLos casos de uso siguen el patr√≥n sandwich?
- ¬øLos puertos reflejan TUS necesidades?
- ¬øLos adaptadores traducen APIs externas?
- ¬øLas dependencias apuntan hacia el centro?

### COMANDO: Se√±ales de problemas

‚ùå **Red flags**:
- Importar frameworks en el dominio
- Casos de uso que conocen detalles de UI
- Puertos que copian APIs externas
- L√≥gica de negocio esparcida por la aplicaci√≥n
- Dificultad para testear sin UI

## CU√ÅNDO APLICAR CLEAN ARCHITECTURE

### COMANDO: Eval√∫a tu proyecto

**APLICA COMPLETO si**:
- Proyecto de mediano/largo plazo
- M√∫ltiples desarrolladores
- Requisitos cambiantes frecuentes
- Necesitas intercambiar servicios externos

**APLICA M√çNIMO si**:
- Proyecto peque√±o o prototipo
- Solo 1-2 desarrolladores
- Requisitos estables
- Tiempo limitado

**M√çNIMO INDISPENSABLE**:
1. Extrae el dominio
2. Respeta la regla de dependencias

### COMANDO: Maneja l√≥gica de negocio compleja

**REGLAS PRAGM√ÅTICAS**:
- NO uses herencia inmediatamente
- HAZ copy-paste primero, refactoriza despu√©s
- OBSERVA patrones antes de abstraer
- DESCOMP√ìN casos de uso interdependientes

## FLUJO DE DESARROLLO RECOMENDADO

### COMANDO: Sigue este orden SIEMPRE

1. **Dise√±a entidades del dominio**: Tipos y transformaciones puras
2. **Define puertos**: Qu√© necesita tu aplicaci√≥n del mundo exterior
3. **Implementa casos de uso**: Orquestaci√≥n usando puertos y dominio
4. **Crea adaptadores**: Implementaci√≥n real de puertos
5. **Conecta UI**: Componentes que usan casos de uso via hooks

### COMANDO: Validaci√≥n continua

En cada paso, preg√∫ntate:
- ¬øLas dependencias apuntan hacia adentro?
- ¬øPuedo testear esta parte aisladamente?
- ¬øPuedo cambiar tecnolog√≠as sin afectar el dominio?

## ADAPTACI√ìN PARA NEXT.JS 14+ (APP ROUTER)

### COMANDO: Estructura de carpetas h√≠brida para Next.js

```
src/
‚îú‚îÄ‚îÄ app/                      # Next.js App Router
‚îÇ   ‚îú‚îÄ‚îÄ (auth)/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx     # Server Component
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ register/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ page.tsx     # Server Component
‚îÇ   ‚îú‚îÄ‚îÄ dashboard/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx         # Server Component
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ loading.tsx      # Loading UI
‚îÇ   ‚îú‚îÄ‚îÄ api/                 # API Routes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ orders/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ route.ts     # Server Actions como adaptadores
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx           # Root Layout
‚îÇ   ‚îî‚îÄ‚îÄ page.tsx             # Home Page
‚îú‚îÄ‚îÄ core/                    # Clean Architecture Core
‚îÇ   ‚îú‚îÄ‚îÄ domain/              # Entidades y transformaciones
‚îÇ   ‚îú‚îÄ‚îÄ application/         # Casos de uso y puertos
‚îÇ   ‚îî‚îÄ‚îÄ infrastructure/      # Adaptadores (renombrado de services/)
‚îÇ       ‚îú‚îÄ‚îÄ adapters/
‚îÇ       ‚îú‚îÄ‚îÄ server-actions/  # Server Actions espec√≠ficos
‚îÇ       ‚îî‚îÄ‚îÄ providers/       # React Context Providers
‚îî‚îÄ‚îÄ components/              # Componentes UI reutilizables
    ‚îú‚îÄ‚îÄ client/              # "use client" components
    ‚îî‚îÄ‚îÄ server/              # Server components
```

### COMANDO: Maneja Server vs Client Components

```typescript
// components/server/ProductList.tsx (Server Component)
import { getProducts } from "@/core/infrastructure/adapters/productAdapter";

export default async function ProductList() {
  // Datos se obtienen en el servidor
  const products = await getProducts();
  
  return (
    <div>
      {products.map(product => (
        <ProductCard key={product.id} product={product} />
      ))}
    </div>
  );
}

// components/client/AddToCartButton.tsx (Client Component)
"use client";

import { useAddToCart } from "@/core/application/addToCart";

export default function AddToCartButton({ product }: { product: Product }) {
  const { addToCart } = useAddToCart();
  
  const handleClick = () => {
    addToCart(product);
  };
  
  return <button onClick={handleClick}>Add to Cart</button>;
}
```

### COMANDO: Implementa Server Actions como adaptadores

```typescript
// core/infrastructure/server-actions/orderActions.ts
"use server";

import { orderProducts } from "@/core/application/orderProducts";
import { redirect } from "next/navigation";

export async function processOrderAction(formData: FormData) {
  const userId = formData.get("userId") as string;
  const cartData = formData.get("cart") as string;
  
  try {
    // Usa el caso de uso existente
    const result = await orderProducts(
      JSON.parse(userId),
      JSON.parse(cartData),
      {
        // Inyecta dependencias del servidor
        payment: getServerPaymentAdapter(),
        notifier: getServerNotificationAdapter(),
        orderStorage: getServerStorageAdapter(),
      }
    );
    
    if (result.success) {
      redirect("/orders/success");
    }
  } catch (error) {
    throw new Error("Order processing failed");
  }
}

// app/checkout/page.tsx
import { processOrderAction } from "@/core/infrastructure/server-actions/orderActions";

export default function CheckoutPage() {
  return (
    <form action={processOrderAction}>
      <input type="hidden" name="userId" value={JSON.stringify(user)} />
      <input type="hidden" name="cart" value={JSON.stringify(cart)} />
      <button type="submit">Process Order</button>
    </form>
  );
}
```

### COMANDO: Adapta puertos para entorno servidor/cliente

```typescript
// core/application/ports.ts

// Puerto universal (funciona en server y client)
export interface PaymentService {
  tryPay(amount: PriceCents): Promise<boolean>;
}

// Puerto espec√≠fico para servidor
export interface ServerPaymentService extends PaymentService {
  validatePayment(transactionId: string): Promise<boolean>;
}

// Puerto espec√≠fico para cliente
export interface ClientPaymentService extends PaymentService {
  initializePaymentWidget(): void;
}

// core/infrastructure/adapters/paymentAdapter.ts
import { isServer } from "@/lib/utils";

export function getPaymentAdapter(): PaymentService {
  if (isServer()) {
    return getServerPaymentAdapter();
  }
  return getClientPaymentAdapter();
}
```

### COMANDO: Maneja estado con Zustand + Server State

```typescript
// core/infrastructure/providers/storeProvider.tsx
"use client";

import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';

interface AppState {
  cart: Cart;
  addToCart: (product: Product) => void;
  clearCart: () => void;
}

export const useAppStore = create<AppState>()(
  devtools(
    persist(
      (set, get) => ({
        cart: { products: [] },
        
        addToCart: (product) => set((state) => ({
          cart: addProduct(state.cart, product) // Usa funci√≥n del dominio
        })),
        
        clearCart: () => set({ cart: { products: [] } }),
      }),
      { name: 'app-store' }
    )
  )
);

// app/layout.tsx
export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html>
      <body>
        <StoreProvider>
          {children}
        </StoreProvider>
      </body>
    </html>
  );
}
```

### COMANDO: Implementa casos de uso h√≠bridos

```typescript
// core/application/orderProducts.ts

// Versi√≥n para cliente
export function useOrderProducts() {
  const { clearCart } = useAppStore();
  
  return async (user: User, cart: Cart) => {
    // Llama a Server Action
    const formData = new FormData();
    formData.append("userId", JSON.stringify(user));
    formData.append("cart", JSON.stringify(cart));
    
    await processOrderAction(formData);
    clearCart(); // Limpia estado cliente
  };
}

// Versi√≥n para servidor (usada por Server Actions)
export async function orderProductsServer(
  user: User, 
  cart: Cart,
  dependencies: ServerDependencies
) {
  const order = createOrder(user, cart);
  
  const paid = await dependencies.payment.tryPay(order.total);
  if (!paid) throw new Error("Payment failed");
  
  await dependencies.orderStorage.save(order);
  
  return { success: true, orderId: order.id };
}
```

### COMANDO: Maneja loading states con Suspense

```typescript
// app/products/page.tsx
import { Suspense } from 'react';
import ProductList from '@/components/server/ProductList';
import ProductListSkeleton from '@/components/server/ProductListSkeleton';

export default function ProductsPage() {
  return (
    <div>
      <h1>Products</h1>
      <Suspense fallback={<ProductListSkeleton />}>
        <ProductList />
      </Suspense>
    </div>
  );
}

// components/server/ProductList.tsx
export default async function ProductList() {
  // Esta funci√≥n puede tardar
  const products = await getProductsFromDomain();
  
  return (
    <div>
      {products.map(product => (
        <ProductCard key={product.id} product={product} />
      ))}
    </div>
  );
}
```

### COMANDO: Optimiza con streaming y parallel data fetching

```typescript
// app/dashboard/page.tsx
export default async function DashboardPage() {
  // Fetch en paralelo
  const [user, orders, cartItems] = await Promise.all([
    getUserData(),
    getOrderHistory(),
    getCartContents()
  ]);

  return (
    <div>
      <UserProfile user={user} />
      <Suspense fallback={<OrdersSkeleton />}>
        <OrderHistory orders={orders} />
      </Suspense>
      <Suspense fallback={<CartSkeleton />}>
        <CartSummary items={cartItems} />
      </Suspense>
    </div>
  );
}
```

### COMANDOS ESPEC√çFICOS PARA NEXT.JS 14+

**COMANDO: Separaci√≥n Server/Client**
- Server Components ‚Üí Fetching inicial, SEO, performance
- Client Components ‚Üí Interactividad, estado local
- Server Actions ‚Üí Mutaciones, formularios

**COMANDO: Adaptadores h√≠bridos**
- Un puerto, m√∫ltiples implementaciones (server/client)
- Factory pattern para seleccionar implementaci√≥n correcta
- Casos de uso que funcionan en ambos entornos

**COMANDO: Estado h√≠brido**
- Server state ‚Üí Datos del dominio (React Query/SWR)
- Client state ‚Üí UI y preferencias (Zustand/Context)
- Persistent state ‚Üí Carrito, configuraci√≥n (localStorage sync)

**COMANDO: Validaci√≥n del flujo Next.js**
‚úÖ ¬øLos casos de uso funcionan tanto en server como client?
‚úÖ ¬øLos adaptadores se adaptan al entorno de ejecuci√≥n?
‚úÖ ¬øEl dominio sigue siendo independiente de Next.js?
‚úÖ ¬øLos Server Actions solo orquestan, no contienen l√≥gica de negocio?

---

**RECUERDA**: Clean Architecture es una herramienta para gestionar complejidad. Para proyectos simples, enf√≥cate en extraer dominio y respetar dependencias. Para proyectos complejos, aplica toda la arquitectura.