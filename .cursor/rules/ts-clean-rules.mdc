---
alwaysApply: true
---

# GuÃ­a Completa: Clean Architecture para Frontend (TypeScript + React)

## CONCEPTOS FUNDAMENTALES

### COMANDO: Entiende los 3 principios bÃ¡sicos
1. **SeparaciÃ³n por proximidad al dominio**: Cuanto mÃ¡s cerca del centro, mÃ¡s importante para el negocio
2. **Dominio independiente**: La lÃ³gica de negocio no debe depender de frameworks o servicios externos
3. **AdaptaciÃ³n externa**: Los servicios externos se adaptan a nuestras necesidades, no al revÃ©s

## ESTRUCTURA DE CARPETAS OBLIGATORIA

```
src/
â”œâ”€â”€ domain/                    # CENTRO: Entidades y transformaciones
â”‚   â”œâ”€â”€ user.ts               # Tipos y funciones de usuario
â”‚   â”œâ”€â”€ product.ts            # Tipos y funciones de producto
â”‚   â”œâ”€â”€ cart.ts               # Tipos y funciones de carrito
â”‚   â””â”€â”€ order.ts              # Tipos y funciones de orden
â”œâ”€â”€ application/              # CAPA 2: Casos de uso y puertos
â”‚   â”œâ”€â”€ addToCart.ts          # Caso de uso: agregar al carrito
â”‚   â”œâ”€â”€ authenticate.ts       # Caso de uso: autenticaciÃ³n
â”‚   â”œâ”€â”€ orderProducts.ts      # Caso de uso: procesar orden
â”‚   â””â”€â”€ ports.ts              # Interfaces para servicios externos
â”œâ”€â”€ services/                 # CAPA 3: Adaptadores
â”‚   â”œâ”€â”€ authAdapter.ts        # Adaptador de autenticaciÃ³n
â”‚   â”œâ”€â”€ notificationAdapter.ts # Adaptador de notificaciones
â”‚   â”œâ”€â”€ paymentAdapter.ts     # Adaptador de pagos
â”‚   â”œâ”€â”€ storageAdapter.ts     # Adaptador de almacenamiento
â”‚   â”œâ”€â”€ api.ts                # Cliente API
â”‚   â””â”€â”€ store.tsx             # Store global (React Context)
â”œâ”€â”€ ui/                       # CAPA 3: Componentes React
â”‚   â””â”€â”€ components/
â”œâ”€â”€ lib/                      # Utilidades tÃ©cnicas
â””â”€â”€ shared-kernel.d.ts        # Tipos compartidos globales
```

## REGLA DE DEPENDENCIAS (INVIOLABLE)

**COMANDO FUNDAMENTAL**: Las dependencias SIEMPRE apuntan hacia el centro
- âœ… `domain/` â†’ NO DEPENDE DE NADA (ni siquiera de `lib/`)
- âœ… `application/` â†’ Solo puede importar de `domain/`
- âœ… `services/` y `ui/` â†’ Pueden importar de `application/` y `domain/`
- âŒ NUNCA al revÃ©s

```
[UI/Services] â†’ [Application] â†’ [Domain]
```

## PASO 1: CREAR SHARED KERNEL

**COMANDO**: Define tipos primitivos mejorados ANTES que todo

```typescript
// shared-kernel.d.ts
type Email = string;
type UniqueId = string;
type DateTimeString = string;
type PriceCents = number;
type Ingredient = string;

// Para mejor tipado (recomendado)
type Currency = "USD" | "EUR" | "COP";
type Price = {
  value: PriceCents;
  currency: Currency;
};
```

**REGLAS DEL SHARED KERNEL**:
- Solo tipos que CUALQUIER parte del sistema pueda usar
- Basado en tipos primitivos del lenguaje
- No aumenta acoplamiento entre mÃ³dulos
- MÃ­nimo indispensable

## PASO 2: DISEÃ‘AR DOMINIO (DOMAIN LAYER)

### COMANDO: Crea tipos de entidades principales

```typescript
// domain/user.ts
export type UserName = string;
export type User = {
  id: UniqueId;
  name: UserName;
  email: Email;
  preferences: Ingredient[];
  allergies: Ingredient[];
};

// domain/product.ts
export type ProductTitle = string;
export type Product = {
  id: UniqueId;
  title: ProductTitle;
  price: PriceCents;
  toppings: Ingredient[];
};

// domain/cart.ts
export type Cart = {
  products: Product[];
};

// domain/order.ts
export type OrderStatus = "new" | "delivery" | "completed";
export type Order = {
  user: UniqueId;
  cart: Cart;
  created: DateTimeString;
  status: OrderStatus;
  total: PriceCents;
};
```

### COMANDO: Crea funciones de transformaciÃ³n puras

**REGLA**: Todas las funciones deben ser puras (sin efectos secundarios)

```typescript
// domain/user.ts
export function hasAllergy(user: User, ingredient: Ingredient): boolean {
  return user.allergies.includes(ingredient);
}

export function hasPreference(user: User, ingredient: Ingredient): boolean {
  return user.preferences.includes(ingredient);
}

// domain/cart.ts
export function addProduct(cart: Cart, product: Product): Cart {
  return { ...cart, products: [...cart.products, product] };
}

export function contains(cart: Cart, product: Product): boolean {
  return cart.products.some(({ id }) => id === product.id);
}

// domain/product.ts
export function totalPrice(products: Product[]): PriceCents {
  return products.reduce((total, { price }) => total + price, 0);
}

// domain/order.ts
export function createOrder(user: User, cart: Cart): Order {
  return {
    user: user.id,
    cart,
    created: new Date().toISOString(),
    status: "new",
    total: totalPrice(cart.products),
  };
}
```

### COMANDO: Valida relaciones entre entidades
- Dibuja diagrama de entidades
- Verifica que las relaciones tengan sentido
- AsegÃºrate de que tienes toda la informaciÃ³n necesaria

## PASO 3: DISEÃ‘AR PUERTOS (APPLICATION LAYER)

### COMANDO: Define puertos convenientes para TU aplicaciÃ³n

**REGLA**: Los puertos reflejan lo que TU aplicaciÃ³n necesita, no lo que ofrecen servicios externos

```typescript
// application/ports.ts

// Puerto para pagos
export interface PaymentService {
  tryPay(amount: PriceCents): Promise<boolean>;
}

// Puerto para notificaciones
export interface NotificationService {
  notify(message: string): void;
}

// Puerto para almacenamiento local
export interface OrdersStorageService {
  orders: Order[];
  updateOrders(orders: Order[]): void;
}

export interface CartStorageService {
  cart: Cart;
  updateCart(cart: Cart): void;
  emptyCart(): void;
}

// Puerto para persistencia
export interface ApiService {
  saveOrder(order: Order): Promise<void>;
  getProducts(): Promise<Product[]>;
}
```

## PASO 4: IMPLEMENTAR CASOS DE USO

### COMANDO: Usa el patrÃ³n "sandwich" para casos de uso

**PATRÃ“N OBLIGATORIO**: Efecto secundario â†’ TransformaciÃ³n pura â†’ Efecto secundario

```typescript
// application/orderProducts.ts

// Stubs temporales para diseÃ±o
const payment: PaymentService = {} as PaymentService;
const notifier: NotificationService = {} as NotificationService;
const orderStorage: OrdersStorageService = {} as OrdersStorageService;
const cartStorage: CartStorageService = {} as CartStorageService;

async function orderProducts(user: User, cart: Cart) {
  // 1. TransformaciÃ³n pura (dominio)
  const order = createOrder(user, cart);

  // 2. Efecto secundario (pago)
  const paid = await payment.tryPay(order.total);
  if (!paid) return notifier.notify("Oops! ğŸ¤·");

  // 3. Efecto secundario (almacenamiento)
  const { orders } = orderStorage;
  orderStorage.updateOrders([...orders, order]);
  cartStorage.emptyCart();
}
```

### COMANDO: Integra casos de uso con React usando hooks

```typescript
// application/orderProducts.ts
export function useOrderProducts() {
  const notifier = useNotifier();
  const payment = usePayment();
  const orderStorage = useOrdersStorage();
  const cartStorage = useCartStorage();

  async function orderProducts(user: User, cart: Cart) {
    const order = createOrder(user, cart);

    const paid = await payment.tryPay(order.total);
    if (!paid) return notifier.notify("Oops! ğŸ¤·");

    const { orders } = orderStorage;
    orderStorage.updateOrders([...orders, order]);
    cartStorage.emptyCart();
  }

  return { orderProducts };
}
```

**NOTA**: El hook actÃºa como "dependency injection rudimentario" usando closures

## PASO 5: IMPLEMENTAR ADAPTADORES

### COMANDO: Crea adaptadores para servicios reales

```typescript
// services/paymentAdapter.ts
import { PaymentService } from "../application/ports";
import { fakeApi } from "./api";

export function usePayment(): PaymentService {
  return {
    tryPay(amount: PriceCents) {
      // Simula llamada a servicio real
      return fakeApi(true);
    },
  };
}

// services/notificationAdapter.ts
import { NotificationService } from "../application/ports";

export function useNotifier(): NotificationService {
  return {
    notify: (message: string) => window.alert(message),
  };
}

// services/api.ts
export function fakeApi<TResponse>(response: TResponse): Promise<TResponse> {
  return new Promise((res) => setTimeout(() => res(response), 450));
}
```

### COMANDO: Implementa almacenamiento con React Context

```typescript
// services/store.tsx
const StoreContext = React.createContext<any>({});
export const useStore = () => useContext(StoreContext);

export const Provider: React.FC = ({ children }) => {
  const [orders, setOrders] = useState<Order[]>([]);
  const [cart, setCart] = useState<Cart>({ products: [] });

  const value = {
    orders,
    updateOrders: setOrders,
    cart,
    updateCart: setCart,
    emptyCart: () => setCart({ products: [] }),
  };

  return (
    <StoreContext.Provider value={value}>
      {children}
    </StoreContext.Provider>
  );
};

// services/storageAdapter.ts
export function useOrdersStorage(): OrdersStorageService {
  return useStore();
}

export function useCartStorage(): CartStorageService {
  return useStore();
}
```

### COMANDO: Conecta UI con casos de uso

```typescript
// ui/components/Buy.tsx
export function Buy() {
  const { orderProducts } = useOrderProducts();
  const [loading, setLoading] = useState(false);

  async function handleSubmit(e: React.FormEvent) {
    setLoading(true);
    e.preventDefault();

    // Llamada directa al caso de uso
    await orderProducts(user!, cart);
    setLoading(false);
  }

  return (
    <section>
      <h2>Checkout</h2>
      <form onSubmit={handleSubmit}>
        <button type="submit" disabled={loading}>
          {loading ? "Processing..." : "Order Now"}
        </button>
      </form>
    </section>
  );
}
```

## MEJORES PRÃCTICAS ESPECÃFICAS PARA FRONTEND

### COMANDO: Maneja precios correctamente

```typescript
// âŒ Malo: solo nÃºmero
type PriceCents = number;

// âœ… Bueno: objeto con moneda
type Currency = "USD" | "EUR" | "COP";
type Price = {
  value: PriceCents;
  currency: Currency;
};
```

**REGLA**: Siempre almacena dinero en la fracciÃ³n mÃ¡s pequeÃ±a (centavos)

### COMANDO: Evita dependencias en el dominio

```typescript
// âŒ Malo: dependencia oculta
export function createOrder(user: User, cart: Cart): Order {
  return {
    // ...
    created: new Date().toISOString(), // Dependencia!
  };
}

// âœ… Bueno: inyecta dependencias
export function createOrder(
  user: User, 
  cart: Cart, 
  created: DateTimeString
): Order {
  return {
    // ...
    created,
  };
}
```

### COMANDO: Usa branded types para mayor seguridad

```typescript
// En lugar de type aliases simples
type UserId = string & { readonly brand: unique symbol };
type Email = string & { readonly brand: unique symbol };

// FunciÃ³n helper para crear branded types
function createUserId(value: string): UserId {
  return value as UserId;
}
```

### COMANDO: Organiza por componentes para proyectos grandes

```
// Alternativa para proyectos complejos
src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ authentication/
â”‚   â”‚   â”œâ”€â”€ domain/
â”‚   â”‚   â”œâ”€â”€ application/
â”‚   â”‚   â””â”€â”€ adapters/
â”‚   â”œâ”€â”€ user-management/
â”‚   â”‚   â”œâ”€â”€ domain/
â”‚   â”‚   â”œâ”€â”€ application/
â”‚   â”‚   â””â”€â”€ adapters/
â”‚   â””â”€â”€ billing/
â”‚       â”œâ”€â”€ domain/
â”‚       â”œâ”€â”€ application/
â”‚       â””â”€â”€ adapters/
```

### COMANDO: Haz casos de uso mÃ¡s testeable

```typescript
// âŒ Malo: difÃ­cil de testear
export function useOrderProducts() {
  const services = getServices(); // Acoplado a React
  
  async function orderProducts(user: User, cart: Cart) {
    // lÃ³gica acoplada
  }
  
  return { orderProducts };
}

// âœ… Bueno: fÃ¡cil de testear
type Dependencies = {
  notifier?: NotificationService;
  payment?: PaymentService;
  orderStorage?: OrderStorageService;
};

async function orderProducts(
  user: User,
  cart: Cart,
  dependencies: Dependencies = defaultDependencies
) {
  const { notifier, payment, orderStorage } = dependencies;
  // lÃ³gica pura
}

// Hook como adaptador
function useOrderProducts() {
  const notifier = useNotifier();
  const payment = usePayment();
  const orderStorage = useOrdersStorage();

  return (user: User, cart: Cart) =>
    orderProducts(user, cart, { notifier, payment, orderStorage });
}
```

## COMANDOS DE VALIDACIÃ“N

### COMANDO: Verifica tu implementaciÃ³n

âœ… **Checklist obligatorio**:
- Â¿El dominio no importa nada externo?
- Â¿Los casos de uso siguen el patrÃ³n sandwich?
- Â¿Los puertos reflejan TUS necesidades?
- Â¿Los adaptadores traducen APIs externas?
- Â¿Las dependencias apuntan hacia el centro?

### COMANDO: SeÃ±ales de problemas

âŒ **Red flags**:
- Importar frameworks en el dominio
- Casos de uso que conocen detalles de UI
- Puertos que copian APIs externas
- LÃ³gica de negocio esparcida por la aplicaciÃ³n
- Dificultad para testear sin UI

## CUÃNDO APLICAR CLEAN ARCHITECTURE

### COMANDO: EvalÃºa tu proyecto

**APLICA COMPLETO si**:
- Proyecto de mediano/largo plazo
- MÃºltiples desarrolladores
- Requisitos cambiantes frecuentes
- Necesitas intercambiar servicios externos

**APLICA MÃNIMO si**:
- Proyecto pequeÃ±o o prototipo
- Solo 1-2 desarrolladores
- Requisitos estables
- Tiempo limitado

**MÃNIMO INDISPENSABLE**:
1. Extrae el dominio
2. Respeta la regla de dependencias

### COMANDO: Maneja lÃ³gica de negocio compleja

**REGLAS PRAGMÃTICAS**:
- NO uses herencia inmediatamente
- HAZ copy-paste primero, refactoriza despuÃ©s
- OBSERVA patrones antes de abstraer
- DESCOMPÃ“N casos de uso interdependientes

## FLUJO DE DESARROLLO RECOMENDADO

### COMANDO: Sigue este orden SIEMPRE

1. **DiseÃ±a entidades del dominio**: Tipos y transformaciones puras
2. **Define puertos**: QuÃ© necesita tu aplicaciÃ³n del mundo exterior
3. **Implementa casos de uso**: OrquestaciÃ³n usando puertos y dominio
4. **Crea adaptadores**: ImplementaciÃ³n real de puertos
5. **Conecta UI**: Componentes que usan casos de uso via hooks

### COMANDO: ValidaciÃ³n continua

En cada paso, pregÃºntate:
- Â¿Las dependencias apuntan hacia adentro?
- Â¿Puedo testear esta parte aisladamente?
- Â¿Puedo cambiar tecnologÃ­as sin afectar el dominio?

---

**RECUERDA**: Clean Architecture es una herramienta para gestionar complejidad. Para proyectos simples, enfÃ³cate en extraer dominio y respetar dependencias. Para proyectos complejos, aplica toda la arquitectura.





## NEXT JS 14 EN ADELANTE

# GuÃ­a Completa: Clean Architecture para Frontend (TypeScript + React)

## CONCEPTOS FUNDAMENTALES

### COMANDO: Entiende los 3 principios bÃ¡sicos
1. **SeparaciÃ³n por proximidad al dominio**: Cuanto mÃ¡s cerca del centro, mÃ¡s importante para el negocio
2. **Dominio independiente**: La lÃ³gica de negocio no debe depender de frameworks o servicios externos
3. **AdaptaciÃ³n externa**: Los servicios externos se adaptan a nuestras necesidades, no al revÃ©s

## ESTRUCTURA DE CARPETAS OBLIGATORIA

```
src/
â”œâ”€â”€ domain/                    # CENTRO: Entidades y transformaciones
â”‚   â”œâ”€â”€ user.ts               # Tipos y funciones de usuario
â”‚   â”œâ”€â”€ product.ts            # Tipos y funciones de producto
â”‚   â”œâ”€â”€ cart.ts               # Tipos y funciones de carrito
â”‚   â””â”€â”€ order.ts              # Tipos y funciones de orden
â”œâ”€â”€ application/              # CAPA 2: Casos de uso y puertos
â”‚   â”œâ”€â”€ addToCart.ts          # Caso de uso: agregar al carrito
â”‚   â”œâ”€â”€ authenticate.ts       # Caso de uso: autenticaciÃ³n
â”‚   â”œâ”€â”€ orderProducts.ts      # Caso de uso: procesar orden
â”‚   â””â”€â”€ ports.ts              # Interfaces para servicios externos
â”œâ”€â”€ services/                 # CAPA 3: Adaptadores
â”‚   â”œâ”€â”€ authAdapter.ts        # Adaptador de autenticaciÃ³n
â”‚   â”œâ”€â”€ notificationAdapter.ts # Adaptador de notificaciones
â”‚   â”œâ”€â”€ paymentAdapter.ts     # Adaptador de pagos
â”‚   â”œâ”€â”€ storageAdapter.ts     # Adaptador de almacenamiento
â”‚   â”œâ”€â”€ api.ts                # Cliente API
â”‚   â””â”€â”€ store.tsx             # Store global (React Context)
â”œâ”€â”€ ui/                       # CAPA 3: Componentes React
â”‚   â””â”€â”€ components/
â”œâ”€â”€ lib/                      # Utilidades tÃ©cnicas
â””â”€â”€ shared-kernel.d.ts        # Tipos compartidos globales
```

## REGLA DE DEPENDENCIAS (INVIOLABLE)

**COMANDO FUNDAMENTAL**: Las dependencias SIEMPRE apuntan hacia el centro
- âœ… `domain/` â†’ NO DEPENDE DE NADA (ni siquiera de `lib/`)
- âœ… `application/` â†’ Solo puede importar de `domain/`
- âœ… `services/` y `ui/` â†’ Pueden importar de `application/` y `domain/`
- âŒ NUNCA al revÃ©s

```
[UI/Services] â†’ [Application] â†’ [Domain]
```

## PASO 1: CREAR SHARED KERNEL

**COMANDO**: Define tipos primitivos mejorados ANTES que todo

```typescript
// shared-kernel.d.ts
type Email = string;
type UniqueId = string;
type DateTimeString = string;
type PriceCents = number;
type Ingredient = string;

// Para mejor tipado (recomendado)
type Currency = "USD" | "EUR" | "COP";
type Price = {
  value: PriceCents;
  currency: Currency;
};
```

**REGLAS DEL SHARED KERNEL**:
- Solo tipos que CUALQUIER parte del sistema pueda usar
- Basado en tipos primitivos del lenguaje
- No aumenta acoplamiento entre mÃ³dulos
- MÃ­nimo indispensable

## PASO 2: DISEÃ‘AR DOMINIO (DOMAIN LAYER)

### COMANDO: Crea tipos de entidades principales

```typescript
// domain/user.ts
export type UserName = string;
export type User = {
  id: UniqueId;
  name: UserName;
  email: Email;
  preferences: Ingredient[];
  allergies: Ingredient[];
};

// domain/product.ts
export type ProductTitle = string;
export type Product = {
  id: UniqueId;
  title: ProductTitle;
  price: PriceCents;
  toppings: Ingredient[];
};

// domain/cart.ts
export type Cart = {
  products: Product[];
};

// domain/order.ts
export type OrderStatus = "new" | "delivery" | "completed";
export type Order = {
  user: UniqueId;
  cart: Cart;
  created: DateTimeString;
  status: OrderStatus;
  total: PriceCents;
};
```

### COMANDO: Crea funciones de transformaciÃ³n puras

**REGLA**: Todas las funciones deben ser puras (sin efectos secundarios)

```typescript
// domain/user.ts
export function hasAllergy(user: User, ingredient: Ingredient): boolean {
  return user.allergies.includes(ingredient);
}

export function hasPreference(user: User, ingredient: Ingredient): boolean {
  return user.preferences.includes(ingredient);
}

// domain/cart.ts
export function addProduct(cart: Cart, product: Product): Cart {
  return { ...cart, products: [...cart.products, product] };
}

export function contains(cart: Cart, product: Product): boolean {
  return cart.products.some(({ id }) => id === product.id);
}

// domain/product.ts
export function totalPrice(products: Product[]): PriceCents {
  return products.reduce((total, { price }) => total + price, 0);
}

// domain/order.ts
export function createOrder(user: User, cart: Cart): Order {
  return {
    user: user.id,
    cart,
    created: new Date().toISOString(),
    status: "new",
    total: totalPrice(cart.products),
  };
}
```

### COMANDO: Valida relaciones entre entidades
- Dibuja diagrama de entidades
- Verifica que las relaciones tengan sentido
- AsegÃºrate de que tienes toda la informaciÃ³n necesaria

## PASO 3: DISEÃ‘AR PUERTOS (APPLICATION LAYER)

### COMANDO: Define puertos convenientes para TU aplicaciÃ³n

**REGLA**: Los puertos reflejan lo que TU aplicaciÃ³n necesita, no lo que ofrecen servicios externos

```typescript
// application/ports.ts

// Puerto para pagos
export interface PaymentService {
  tryPay(amount: PriceCents): Promise<boolean>;
}

// Puerto para notificaciones
export interface NotificationService {
  notify(message: string): void;
}

// Puerto para almacenamiento local
export interface OrdersStorageService {
  orders: Order[];
  updateOrders(orders: Order[]): void;
}

export interface CartStorageService {
  cart: Cart;
  updateCart(cart: Cart): void;
  emptyCart(): void;
}

// Puerto para persistencia
export interface ApiService {
  saveOrder(order: Order): Promise<void>;
  getProducts(): Promise<Product[]>;
}
```

## PASO 4: IMPLEMENTAR CASOS DE USO

### COMANDO: Usa el patrÃ³n "sandwich" para casos de uso

**PATRÃ“N OBLIGATORIO**: Efecto secundario â†’ TransformaciÃ³n pura â†’ Efecto secundario

```typescript
// application/orderProducts.ts

// Stubs temporales para diseÃ±o
const payment: PaymentService = {} as PaymentService;
const notifier: NotificationService = {} as NotificationService;
const orderStorage: OrdersStorageService = {} as OrdersStorageService;
const cartStorage: CartStorageService = {} as CartStorageService;

async function orderProducts(user: User, cart: Cart) {
  // 1. TransformaciÃ³n pura (dominio)
  const order = createOrder(user, cart);

  // 2. Efecto secundario (pago)
  const paid = await payment.tryPay(order.total);
  if (!paid) return notifier.notify("Oops! ğŸ¤·");

  // 3. Efecto secundario (almacenamiento)
  const { orders } = orderStorage;
  orderStorage.updateOrders([...orders, order]);
  cartStorage.emptyCart();
}
```

### COMANDO: Integra casos de uso con React usando hooks

```typescript
// application/orderProducts.ts
export function useOrderProducts() {
  const notifier = useNotifier();
  const payment = usePayment();
  const orderStorage = useOrdersStorage();
  const cartStorage = useCartStorage();

  async function orderProducts(user: User, cart: Cart) {
    const order = createOrder(user, cart);

    const paid = await payment.tryPay(order.total);
    if (!paid) return notifier.notify("Oops! ğŸ¤·");

    const { orders } = orderStorage;
    orderStorage.updateOrders([...orders, order]);
    cartStorage.emptyCart();
  }

  return { orderProducts };
}
```

**NOTA**: El hook actÃºa como "dependency injection rudimentario" usando closures

## PASO 5: IMPLEMENTAR ADAPTADORES

### COMANDO: Crea adaptadores para servicios reales

```typescript
// services/paymentAdapter.ts
import { PaymentService } from "../application/ports";
import { fakeApi } from "./api";

export function usePayment(): PaymentService {
  return {
    tryPay(amount: PriceCents) {
      // Simula llamada a servicio real
      return fakeApi(true);
    },
  };
}

// services/notificationAdapter.ts
import { NotificationService } from "../application/ports";

export function useNotifier(): NotificationService {
  return {
    notify: (message: string) => window.alert(message),
  };
}

// services/api.ts
export function fakeApi<TResponse>(response: TResponse): Promise<TResponse> {
  return new Promise((res) => setTimeout(() => res(response), 450));
}
```

### COMANDO: Implementa almacenamiento con React Context

```typescript
// services/store.tsx
const StoreContext = React.createContext<any>({});
export const useStore = () => useContext(StoreContext);

export const Provider: React.FC = ({ children }) => {
  const [orders, setOrders] = useState<Order[]>([]);
  const [cart, setCart] = useState<Cart>({ products: [] });

  const value = {
    orders,
    updateOrders: setOrders,
    cart,
    updateCart: setCart,
    emptyCart: () => setCart({ products: [] }),
  };

  return (
    <StoreContext.Provider value={value}>
      {children}
    </StoreContext.Provider>
  );
};

// services/storageAdapter.ts
export function useOrdersStorage(): OrdersStorageService {
  return useStore();
}

export function useCartStorage(): CartStorageService {
  return useStore();
}
```

### COMANDO: Conecta UI con casos de uso

```typescript
// ui/components/Buy.tsx
export function Buy() {
  const { orderProducts } = useOrderProducts();
  const [loading, setLoading] = useState(false);

  async function handleSubmit(e: React.FormEvent) {
    setLoading(true);
    e.preventDefault();

    // Llamada directa al caso de uso
    await orderProducts(user!, cart);
    setLoading(false);
  }

  return (
    <section>
      <h2>Checkout</h2>
      <form onSubmit={handleSubmit}>
        <button type="submit" disabled={loading}>
          {loading ? "Processing..." : "Order Now"}
        </button>
      </form>
    </section>
  );
}
```

## MEJORES PRÃCTICAS ESPECÃFICAS PARA FRONTEND

### COMANDO: Maneja precios correctamente

```typescript
// âŒ Malo: solo nÃºmero
type PriceCents = number;

// âœ… Bueno: objeto con moneda
type Currency = "USD" | "EUR" | "COP";
type Price = {
  value: PriceCents;
  currency: Currency;
};
```

**REGLA**: Siempre almacena dinero en la fracciÃ³n mÃ¡s pequeÃ±a (centavos)

### COMANDO: Evita dependencias en el dominio

```typescript
// âŒ Malo: dependencia oculta
export function createOrder(user: User, cart: Cart): Order {
  return {
    // ...
    created: new Date().toISOString(), // Dependencia!
  };
}

// âœ… Bueno: inyecta dependencias
export function createOrder(
  user: User, 
  cart: Cart, 
  created: DateTimeString
): Order {
  return {
    // ...
    created,
  };
}
```

### COMANDO: Usa branded types para mayor seguridad

```typescript
// En lugar de type aliases simples
type UserId = string & { readonly brand: unique symbol };
type Email = string & { readonly brand: unique symbol };

// FunciÃ³n helper para crear branded types
function createUserId(value: string): UserId {
  return value as UserId;
}
```

### COMANDO: Organiza por componentes para proyectos grandes

```
// Alternativa para proyectos complejos
src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ authentication/
â”‚   â”‚   â”œâ”€â”€ domain/
â”‚   â”‚   â”œâ”€â”€ application/
â”‚   â”‚   â””â”€â”€ adapters/
â”‚   â”œâ”€â”€ user-management/
â”‚   â”‚   â”œâ”€â”€ domain/
â”‚   â”‚   â”œâ”€â”€ application/
â”‚   â”‚   â””â”€â”€ adapters/
â”‚   â””â”€â”€ billing/
â”‚       â”œâ”€â”€ domain/
â”‚       â”œâ”€â”€ application/
â”‚       â””â”€â”€ adapters/
```

### COMANDO: Haz casos de uso mÃ¡s testeable

```typescript
// âŒ Malo: difÃ­cil de testear
export function useOrderProducts() {
  const services = getServices(); // Acoplado a React
  
  async function orderProducts(user: User, cart: Cart) {
    // lÃ³gica acoplada
  }
  
  return { orderProducts };
}

// âœ… Bueno: fÃ¡cil de testear
type Dependencies = {
  notifier?: NotificationService;
  payment?: PaymentService;
  orderStorage?: OrderStorageService;
};

async function orderProducts(
  user: User,
  cart: Cart,
  dependencies: Dependencies = defaultDependencies
) {
  const { notifier, payment, orderStorage } = dependencies;
  // lÃ³gica pura
}

// Hook como adaptador
function useOrderProducts() {
  const notifier = useNotifier();
  const payment = usePayment();
  const orderStorage = useOrdersStorage();

  return (user: User, cart: Cart) =>
    orderProducts(user, cart, { notifier, payment, orderStorage });
}
```

## COMANDOS DE VALIDACIÃ“N

### COMANDO: Verifica tu implementaciÃ³n

âœ… **Checklist obligatorio**:
- Â¿El dominio no importa nada externo?
- Â¿Los casos de uso siguen el patrÃ³n sandwich?
- Â¿Los puertos reflejan TUS necesidades?
- Â¿Los adaptadores traducen APIs externas?
- Â¿Las dependencias apuntan hacia el centro?

### COMANDO: SeÃ±ales de problemas

âŒ **Red flags**:
- Importar frameworks en el dominio
- Casos de uso que conocen detalles de UI
- Puertos que copian APIs externas
- LÃ³gica de negocio esparcida por la aplicaciÃ³n
- Dificultad para testear sin UI

## CUÃNDO APLICAR CLEAN ARCHITECTURE

### COMANDO: EvalÃºa tu proyecto

**APLICA COMPLETO si**:
- Proyecto de mediano/largo plazo
- MÃºltiples desarrolladores
- Requisitos cambiantes frecuentes
- Necesitas intercambiar servicios externos

**APLICA MÃNIMO si**:
- Proyecto pequeÃ±o o prototipo
- Solo 1-2 desarrolladores
- Requisitos estables
- Tiempo limitado

**MÃNIMO INDISPENSABLE**:
1. Extrae el dominio
2. Respeta la regla de dependencias

### COMANDO: Maneja lÃ³gica de negocio compleja

**REGLAS PRAGMÃTICAS**:
- NO uses herencia inmediatamente
- HAZ copy-paste primero, refactoriza despuÃ©s
- OBSERVA patrones antes de abstraer
- DESCOMPÃ“N casos de uso interdependientes

## FLUJO DE DESARROLLO RECOMENDADO

### COMANDO: Sigue este orden SIEMPRE

1. **DiseÃ±a entidades del dominio**: Tipos y transformaciones puras
2. **Define puertos**: QuÃ© necesita tu aplicaciÃ³n del mundo exterior
3. **Implementa casos de uso**: OrquestaciÃ³n usando puertos y dominio
4. **Crea adaptadores**: ImplementaciÃ³n real de puertos
5. **Conecta UI**: Componentes que usan casos de uso via hooks

### COMANDO: ValidaciÃ³n continua

En cada paso, pregÃºntate:
- Â¿Las dependencias apuntan hacia adentro?
- Â¿Puedo testear esta parte aisladamente?
- Â¿Puedo cambiar tecnologÃ­as sin afectar el dominio?

## ADAPTACIÃ“N PARA NEXT.JS 14+ (APP ROUTER)

### COMANDO: Estructura de carpetas hÃ­brida para Next.js

```
src/
â”œâ”€â”€ app/                      # Next.js App Router
â”‚   â”œâ”€â”€ (auth)/
â”‚   â”‚   â”œâ”€â”€ login/
â”‚   â”‚   â”‚   â””â”€â”€ page.tsx     # Server Component
â”‚   â”‚   â””â”€â”€ register/
â”‚   â”‚       â””â”€â”€ page.tsx     # Server Component
â”‚   â”œâ”€â”€ dashboard/
â”‚   â”‚   â”œâ”€â”€ page.tsx         # Server Component
â”‚   â”‚   â””â”€â”€ loading.tsx      # Loading UI
â”‚   â”œâ”€â”€ api/                 # API Routes
â”‚   â”‚   â””â”€â”€ orders/
â”‚   â”‚       â””â”€â”€ route.ts     # Server Actions como adaptadores
â”‚   â”œâ”€â”€ layout.tsx           # Root Layout
â”‚   â””â”€â”€ page.tsx             # Home Page
â”œâ”€â”€ core/                    # Clean Architecture Core
â”‚   â”œâ”€â”€ domain/              # Entidades y transformaciones
â”‚   â”œâ”€â”€ application/         # Casos de uso y puertos
â”‚   â””â”€â”€ infrastructure/      # Adaptadores (renombrado de services/)
â”‚       â”œâ”€â”€ adapters/
â”‚       â”œâ”€â”€ server-actions/  # Server Actions especÃ­ficos
â”‚       â””â”€â”€ providers/       # React Context Providers
â””â”€â”€ components/              # Componentes UI reutilizables
    â”œâ”€â”€ client/              # "use client" components
    â””â”€â”€ server/              # Server components
```

### COMANDO: Maneja Server vs Client Components

```typescript
// components/server/ProductList.tsx (Server Component)
import { getProducts } from "@/core/infrastructure/adapters/productAdapter";

export default async function ProductList() {
  // Datos se obtienen en el servidor
  const products = await getProducts();
  
  return (
    <div>
      {products.map(product => (
        <ProductCard key={product.id} product={product} />
      ))}
    </div>
  );
}

// components/client/AddToCartButton.tsx (Client Component)
"use client";

import { useAddToCart } from "@/core/application/addToCart";

export default function AddToCartButton({ product }: { product: Product }) {
  const { addToCart } = useAddToCart();
  
  const handleClick = () => {
    addToCart(product);
  };
  
  return <button onClick={handleClick}>Add to Cart</button>;
}
```

### COMANDO: Implementa Server Actions como adaptadores

```typescript
// core/infrastructure/server-actions/orderActions.ts
"use server";

import { orderProducts } from "@/core/application/orderProducts";
import { redirect } from "next/navigation";

export async function processOrderAction(formData: FormData) {
  const userId = formData.get("userId") as string;
  const cartData = formData.get("cart") as string;
  
  try {
    // Usa el caso de uso existente
    const result = await orderProducts(
      JSON.parse(userId),
      JSON.parse(cartData),
      {
        // Inyecta dependencias del servidor
        payment: getServerPaymentAdapter(),
        notifier: getServerNotificationAdapter(),
        orderStorage: getServerStorageAdapter(),
      }
    );
    
    if (result.success) {
      redirect("/orders/success");
    }
  } catch (error) {
    throw new Error("Order processing failed");
  }
}

// app/checkout/page.tsx
import { processOrderAction } from "@/core/infrastructure/server-actions/orderActions";

export default function CheckoutPage() {
  return (
    <form action={processOrderAction}>
      <input type="hidden" name="userId" value={JSON.stringify(user)} />
      <input type="hidden" name="cart" value={JSON.stringify(cart)} />
      <button type="submit">Process Order</button>
    </form>
  );
}
```

### COMANDO: Adapta puertos para entorno servidor/cliente

```typescript
// core/application/ports.ts

// Puerto universal (funciona en server y client)
export interface PaymentService {
  tryPay(amount: PriceCents): Promise<boolean>;
}

// Puerto especÃ­fico para servidor
export interface ServerPaymentService extends PaymentService {
  validatePayment(transactionId: string): Promise<boolean>;
}

// Puerto especÃ­fico para cliente
export interface ClientPaymentService extends PaymentService {
  initializePaymentWidget(): void;
}

// core/infrastructure/adapters/paymentAdapter.ts
import { isServer } from "@/lib/utils";

export function getPaymentAdapter(): PaymentService {
  if (isServer()) {
    return getServerPaymentAdapter();
  }
  return getClientPaymentAdapter();
}
```

### COMANDO: Maneja estado con Zustand + Server State

```typescript
// core/infrastructure/providers/storeProvider.tsx
"use client";

import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';

interface AppState {
  cart: Cart;
  addToCart: (product: Product) => void;
  clearCart: () => void;
}

export const useAppStore = create<AppState>()(
  devtools(
    persist(
      (set, get) => ({
        cart: { products: [] },
        
        addToCart: (product) => set((state) => ({
          cart: addProduct(state.cart, product) // Usa funciÃ³n del dominio
        })),
        
        clearCart: () => set({ cart: { products: [] } }),
      }),
      { name: 'app-store' }
    )
  )
);

// app/layout.tsx
export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html>
      <body>
        <StoreProvider>
          {children}
        </StoreProvider>
      </body>
    </html>
  );
}
```

### COMANDO: Implementa casos de uso hÃ­bridos

```typescript
// core/application/orderProducts.ts

// VersiÃ³n para cliente
export function useOrderProducts() {
  const { clearCart } = useAppStore();
  
  return async (user: User, cart: Cart) => {
    // Llama a Server Action
    const formData = new FormData();
    formData.append("userId", JSON.stringify(user));
    formData.append("cart", JSON.stringify(cart));
    
    await processOrderAction(formData);
    clearCart(); // Limpia estado cliente
  };
}

// VersiÃ³n para servidor (usada por Server Actions)
export async function orderProductsServer(
  user: User, 
  cart: Cart,
  dependencies: ServerDependencies
) {
  const order = createOrder(user, cart);
  
  const paid = await dependencies.payment.tryPay(order.total);
  if (!paid) throw new Error("Payment failed");
  
  await dependencies.orderStorage.save(order);
  
  return { success: true, orderId: order.id };
}
```

### COMANDO: Maneja loading states con Suspense

```typescript
// app/products/page.tsx
import { Suspense } from 'react';
import ProductList from '@/components/server/ProductList';
import ProductListSkeleton from '@/components/server/ProductListSkeleton';

export default function ProductsPage() {
  return (
    <div>
      <h1>Products</h1>
      <Suspense fallback={<ProductListSkeleton />}>
        <ProductList />
      </Suspense>
    </div>
  );
}

// components/server/ProductList.tsx
export default async function ProductList() {
  // Esta funciÃ³n puede tardar
  const products = await getProductsFromDomain();
  
  return (
    <div>
      {products.map(product => (
        <ProductCard key={product.id} product={product} />
      ))}
    </div>
  );
}
```

### COMANDO: Optimiza con streaming y parallel data fetching

```typescript
// app/dashboard/page.tsx
export default async function DashboardPage() {
  // Fetch en paralelo
  const [user, orders, cartItems] = await Promise.all([
    getUserData(),
    getOrderHistory(),
    getCartContents()
  ]);

  return (
    <div>
      <UserProfile user={user} />
      <Suspense fallback={<OrdersSkeleton />}>
        <OrderHistory orders={orders} />
      </Suspense>
      <Suspense fallback={<CartSkeleton />}>
        <CartSummary items={cartItems} />
      </Suspense>
    </div>
  );
}
```

### COMANDOS ESPECÃFICOS PARA NEXT.JS 14+

**COMANDO: SeparaciÃ³n Server/Client**
- Server Components â†’ Fetching inicial, SEO, performance
- Client Components â†’ Interactividad, estado local
- Server Actions â†’ Mutaciones, formularios

**COMANDO: Adaptadores hÃ­bridos**
- Un puerto, mÃºltiples implementaciones (server/client)
- Factory pattern para seleccionar implementaciÃ³n correcta
- Casos de uso que funcionan en ambos entornos

**COMANDO: Estado hÃ­brido**
- Server state â†’ Datos del dominio (React Query/SWR)
- Client state â†’ UI y preferencias (Zustand/Context)
- Persistent state â†’ Carrito, configuraciÃ³n (localStorage sync)

**COMANDO: ValidaciÃ³n del flujo Next.js**
âœ… Â¿Los casos de uso funcionan tanto en server como client?
âœ… Â¿Los adaptadores se adaptan al entorno de ejecuciÃ³n?
âœ… Â¿El dominio sigue siendo independiente de Next.js?
âœ… Â¿Los Server Actions solo orquestan, no contienen lÃ³gica de negocio?

---

**RECUERDA**: Clean Architecture es una herramienta para gestionar complejidad. Para proyectos simples, enfÃ³cate en extraer dominio y respetar dependencias. Para proyectos complejos, aplica toda la arquitectura.